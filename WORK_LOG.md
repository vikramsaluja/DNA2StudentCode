Name: Vikram Saluja

| Date    |     Time     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Update |
|:--------|:------------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| April 5 |    9-10pm    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                I tried to write abstract, efficient code. |
| Oct 16  | 1:00-1:45pm  |                                                                                                                                                                                                                                                                                                                               Orginally, I know that I can solve this probem a similar way to solving it how we did in cs1. This would mean comparing a set of letters to the next set and see if it reoccuring. Then by end your could return the number the number with the most comparisons. One way that I am starting to think about approaching this would be if I could implement a trie or TST in someway to have a constant look up with each of the reoccuring sequences. I'm not too sure how this would work though but I am just trying to think of ways that I could cut down the run time. |
| Oct 16  | 6:00-7:15pm  |                                                                                                                                                                                                                                                                                                                    I tried to continue to think about how I could possibly use a trie or tst but ended up getting stuck. Instead I thinking about if I can use an to then avoid checking overlapping regions of DNA over and over again. I think this would make the orginal cs1 approach to the problem more efficent but I am not sure if that is a strong change in the actual approach to this problem. Once I figured this out I am wondering if there is a way to take the desired sequence and then go through and try and find matches within the sequence so I would only need to make one pass. |
| Oct 19  | 7:00-8:00pm  |                                                                                                                                                                                                                                                                                                                                                                                         I think that this could be more efficient if I am able to make a comparison between the desired sequence that I am looking for the and then compare it with the rest of DNA sequence. Though I am not entirely sure how I would actually code this or if my logic makes sense, so far I think that this could be a possibilty. The one issue that I think might occur with this approach is going back and not just moving on but realzing that another sequence can start previous to the end of the one before. |
| Oct 22  | 9:30-9:55pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                            During this time I initialized all of my variables and my hashes. The main way that my thinking changed during this time was realizing that I need check if the STR is longer than DNA sequence. Since there is a chance that it could be longer, that would then mean that that there is no way that the entirety of the STR is present in the sequence. This is not something that I previously thought about and a necessary case that I needed to address. |
| Oct 23  | 2:15-3:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                        During this time I continued to work on writing my rolling hashes method. The one issue that I found was that I am unsure of the approach that I am taking because of edge cases. It is not totally clear to me how it will adress cases that may go out of bounds or overlap. The main way my thinking has changed is by realizing also that I dont need to change check multiple things since I am using the monte carlo method. |
| Oct 27  | 7:45-10:15pm | During this time I finished implementing the hashing portion of my code and refining it. My thinking changed since I realized that I was jumping too far ahead each time a match was found which caused me to skip possible overlapping runs. I then started to see that the real issue wasnt just finding the matches but controlling the slides. The biggest shift in my thinking however had to do with assuming that as long as my loop condition was i <= dna - str, the alogirthm would stop before going out of range. But then I realized after I did not pass the testTricky() that even small shifts in the index could easily push the window past the end of the DNA sequence. So isntead of treating bounds checking as something that the loop would automatiaclly handle, I added the !indexError which makes sure that every substring and hash calulcaution is valid before it happens.  |


To add a new row to the table, click into a cell and then hit shift-enter.